"""
Delta Compression Exporter â€” stores only changed regions between frames.

For each frame (except the first), computes the bounding box of pixels
that differ from the previous frame and exports only that region.
"""

import os
from ..canvas import Canvas


def _compute_delta(prev: Canvas, curr: Canvas):
    """Find the bounding box of changed pixels between two frames.

    Returns (x, y, w, h, changed_pixels) or None if identical.
    """
    pw = prev.image.load()
    cw = curr.image.load()
    width, height = prev.width, prev.height

    min_x, min_y = width, height
    max_x, max_y = -1, -1

    for y in range(height):
        for x in range(width):
            if pw[x, y] != cw[x, y]:
                min_x = min(min_x, x)
                min_y = min(min_y, y)
                max_x = max(max_x, x)
                max_y = max(max_y, y)

    if max_x < 0:
        return None

    box_w = max_x - min_x + 1
    box_h = max_y - min_y + 1

    return {
        "x": min_x,
        "y": min_y,
        "w": box_w,
        "h": box_h,
    }


def _extract_region_bytes(canvas: Canvas, x: int, y: int, w: int, h: int) -> bytes:
    """Extract horizontal-format bytes for a sub-region of the canvas."""
    pixels = canvas.image.load()
    padded_w = ((w + 7) // 8) * 8
    data = bytearray()

    for row in range(y, y + h):
        for x_byte in range(padded_w // 8):
            byte = 0
            for bit in range(8):
                px = x + x_byte * 8 + bit
                if px < x + w and px < canvas.width and row < canvas.height:
                    if pixels[px, row]:
                        byte |= (0x80 >> bit)
            data.append(byte)

    return bytes(data)


def export_delta(
    frames: list,
    output_path: str,
    width: int,
    height: int,
    fps: int,
    var_prefix: str = "frame",
):
    """Export frames using delta compression.

    First frame is stored in full. Subsequent frames store only the
    bounding box of changed pixels.
    """
    frame_count = len(frames)
    full_frame_size = (width * height) // 8

    lines = []
    total_delta_bytes = 0

    first_data = frames[0].to_bytes("horizontal")
    total_delta_bytes += len(first_data)

    lines.append(f"// ============================================================")
    lines.append(f"// Auto-generated by remotionBinario (DELTA MODE)")
    lines.append(f"// Screen: {width}x{height} | Frames: {frame_count} | FPS: {fps}")
    lines.append(f"// ============================================================")
    lines.append("")
    lines.append("#include <avr/pgmspace.h>")
    lines.append("")
    lines.append("typedef struct {")
    lines.append("  uint8_t x, y, w, h;")
    lines.append("  uint8_t bw; // byte width of delta region")
    lines.append("  const unsigned char* data;")
    lines.append("} DeltaFrame;")
    lines.append("")

    hex_vals = [f"0x{b:02X}" for b in first_data]
    bytes_per_row = width // 8
    lines.append(f"const unsigned char PROGMEM {var_prefix}_0_full[] = {{")
    for rs in range(0, len(hex_vals), bytes_per_row):
        row = hex_vals[rs : rs + bytes_per_row]
        comma = "," if rs + bytes_per_row < len(hex_vals) else ""
        lines.append(f"  {', '.join(row)}{comma}")
    lines.append("};")
    lines.append("")

    deltas = []
    for i in range(1, frame_count):
        delta = _compute_delta(frames[i - 1], frames[i])

        if delta is None:
            deltas.append(None)
            continue

        region_bytes = _extract_region_bytes(
            frames[i], delta["x"], delta["y"], delta["w"], delta["h"]
        )
        total_delta_bytes += len(region_bytes)

        hex_vals = [f"0x{b:02X}" for b in region_bytes]
        bw = ((delta["w"] + 7) // 8)
        lines.append(f"const unsigned char PROGMEM delta_{i}[] = {{")
        for rs in range(0, len(hex_vals), bw):
            row = hex_vals[rs : rs + bw]
            comma = "," if rs + bw < len(hex_vals) else ""
            lines.append(f"  {', '.join(row)}{comma}")
        lines.append("};")
        lines.append("")

        deltas.append(delta)

    lines.append(f"const DeltaFrame deltas[] PROGMEM = {{")
    for i in range(1, frame_count):
        d = deltas[i - 1]
        if d is None:
            lines.append(f"  {{0, 0, 0, 0, 0, NULL}},  // frame {i}: identical")
        else:
            bw = ((d["w"] + 7) // 8)
            lines.append(
                f"  {{{d['x']}, {d['y']}, {d['w']}, {d['h']}, {bw}, delta_{i}}},"
                f"  // frame {i}"
            )
    lines.append("};")
    lines.append("")

    full_total = frame_count * full_frame_size
    savings = ((full_total - total_delta_bytes) / full_total) * 100 if full_total > 0 else 0

    lines.append(f"const uint16_t FRAME_COUNT = {frame_count};")
    lines.append(f"const uint16_t FRAME_W = {width};")
    lines.append(f"const uint16_t FRAME_H = {height};")
    lines.append(f"const uint8_t  FPS = {fps};")
    lines.append("")
    lines.append(f"// Memory: {total_delta_bytes} bytes ({total_delta_bytes / 1024:.2f} KB)")
    lines.append(f"// Full frames would be: {full_total} bytes ({full_total / 1024:.2f} KB)")
    lines.append(f"// Savings: {savings:.1f}%")

    os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    return {
        "path": output_path,
        "total_bytes": total_delta_bytes,
        "full_bytes": full_total,
        "savings_pct": savings,
    }
